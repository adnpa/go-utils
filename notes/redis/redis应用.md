

应用

## 共享session

通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。

例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。

因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。





## 缓存

* https://github.com/DiceDB/dice
  兼容 redis 的、反应灵敏的、可扩展的、高可用性的**统一缓存**，针对现代硬件进行了优化。
* https://github.com/eko/gocache
  一个完整的 Go 缓存库，为您提供多种管理缓存的方式
* https://github.com/go-redis/cache
  小项目

## 缓存雪崩、击穿、穿透

好的,让我们来详细介绍一下 Redis 中常见的几种缓存问题:缓存雪崩、缓存击穿和缓存穿透。

1. **缓存雪崩**:
   - 缓存雪崩指的是在某一时刻发生大规模的缓存失效,导致大量请求打到数据库,引发数据库崩溃的情况。
   - 这通常发生在缓存服务器重启或大量缓存key在某一时间点集中失效的情况下。
   - 解决方案包括:
     - 利用Redis集群提高缓存可用性
     - 为缓存设置合理的过期时间,加入随机因素
     - 给关键数据设置永不过期的缓存

2. **缓存击穿**:
   - 缓存击穿指的是一个存在但在某个时间点刚好失效的 key,这个时候所有的请求都会打到数据库。
   - 这通常发生在访问一些热点数据的情况下。
   - 解决方案包括:
     - 利用互斥锁(Mutex)保证同一时间只有一个线程去查询数据库
     - 设置热点数据永不过期或者过期时间很长

3. **缓存穿透**:
   - 缓存穿透指的是客户端请求的数据在缓存和数据库中都不存在,这将导致每次请求都要打到数据库。
   - 这种情况通常发生在客户端输入一些无意义的数据,从而查询不到结果。
   - 解决方案包括:
     - 对查不到的key设置默认值缓存
     - 采用布隆过滤器等方式提前保留一些可能存在的key
     - 限制频率过高的请求

总的来说,缓存问题的解决方案需要从缓存设计、服务架构等多个层面进行优化。对于特定的业务场景,可以采取不同的预防和补救措施。

关键是要提前预测可能出现的缓存问题,并制定相应的应对策略。通过合理的缓存设计和系统架构,可以大大提高系统的稳定性和可用性。



## 数据库和缓存如何保证一致性

数据库和缓存的一致性是一个需要权衡的问题。通常有以下几种常见的解决方案:

1. **Cache Aside（旁路缓存）**:
   - 这是最简单的方式,先操作缓存,然后再操作数据库。
   - 写操作先更新数据库,然后**删除缓存**;读操作先查缓存,缓存没有再查数据库并更新缓存。
   - 优点是实现简单,可以快速响应客户端请求。
   - 缺点是需要处理缓存失效导致的数据不一致问题。

2. **Read/Write Through**:
   - 读写都先访问缓存,缓存中没有再访问数据库。
   - **写操作先更新数据库,然后更新缓存。**
   - 优点是缓存中的数据和数据库中的数据保持一致。
   - 缺点是响应时间会稍微长一些,因为需要访问数据库。

3. **Write Behind（异步缓存）**:
   - **写操作先更新缓存,然后异步更新数据库。**
   - 优点是可以提高写入性能,且能保证最终一致性。
   - 缺点是需要处理数据库写入失败的情况,且需要复杂的事务管理。

4. **Refresh Ahead**:
   - 缓存数据在临近过期时,提前从数据库加载新数据到缓存。
   - 优点是可以避免缓存过期导致的缓存击穿问题。
   - 缺点是需要根据业务特点**预测**数据的访问模式。

除此之外,还可以使用分布式锁、二级缓存、Cache Writeback等技术来解决一致性问题。

选择哪种方案需要根据具体的业务场景和性能需求来权衡。一般来说,对于对实时性要求不高但对一致性要求高的业务,可以选择Read/Write Through;而对于对实时性要求高但对一致性要求相对较低的业务,可以选择Cache Aside。

总的来说,保证数据库和缓存的一致性需要采取多种技术手段,并结合具体业务特点进行权衡和选择。



## 分布式缓存







## 多级缓存







## 秒杀



## 分布式锁

https://github.com/go-redsync/redsync

### 为什么用Redis

Redis 作为一个中央存储，用于保存锁的状态。它的高性能和原子操作使其成为实现分布式锁的理想选择。

### 向 Redis 请求的流程

以下是实现分布式锁的典型流程：

1. **获取锁**：

   - 节点向 Redis 发送请求，通常使用 `SET` 命令设置一个键（例如锁的名称），并附加一个唯一的值（例如 UUID）和过期时间。

     ```
     SET lock_name unique_value EX 10 NX
     ```

   - 这里，`EX 10` 设置锁的过期时间为 10 秒，`NX` 表示仅在键不存在时设置。

2. **检查锁的状态**：

   - 如果返回值为 `OK`，则表示锁成功获取；如果返回 `nil`，则表示锁已被其他节点占用。

3. **执行临界区操作**：

   - 一旦锁被成功获取，节点可以执行对共享资源的操作。

4. **释放锁**：

   - 操作完成后，节点必须释放锁。释放锁的过程通常涉及**检查当前锁的值是否与节点持有的一致，然后使用 `DEL` 命令删除锁**。
   - 因为涉及多个操作，所以用lua脚本

5. **处理失败与重试**：

   - 如果节点在获取锁时失败，通常会实现重试机制，可能会使用指数退避策略来延迟重试，避免对 Redis 的频繁请求。

6. **延长锁时间**：

   * PEXPIRE

### 关键点

- **原子性**：Redis 的操作是原子的，使用 Lua 脚本可以确保获取和释放锁的过程不会被其他操作干扰。
- **超时机制**：为防止死锁，设置过期时间是非常重要的。即使节点因故障未能释放锁，锁也会在超时后自动释放。
- **一致性**：确保在分布式环境中，所有节点能够正确地获取和释放锁，保持数据的一致性。



## 消息队列







